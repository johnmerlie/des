import math
from abc import ABC
from collections.abc import Mapping
from enum import Enum
from typing import Any, Self
from uuid import UUID, uuid4

from des.errors import DefinitionError


class Discrete(Enum):
    def __new__(cls, *args: Any):
        value = len(cls.__members__) + 1
        obj = object.__new__(cls)
        obj._value_ = value
        return obj


type Input[T] = Mapping[type[T], T]
type Output[T] = Mapping[type[T], T]


class Model[S, I, O](ABC):
    id: UUID
    name: str
    state: S
    States: type[S]

    def __init_subclass__(cls: type[Self]) -> None:
        if not (ST := getattr(cls, "States", None)):
            raise DefinitionError(f"States is not defined for {cls}")
        if not issubclass(ST, Discrete):
            raise DefinitionError(f"States: {ST} must be subclass of Discrete")
        return super().__init_subclass__()

    def __init__(self, initial_state: S, name: str | None = None):
        self.id = uuid4()
        if not name:
            name = f"{self.__class__.__name__}[{self.id}]"
        self.name = name
        self.state = initial_state

    @classmethod
    def time_advance(cls, state: S) -> float:
        """
        The time advance function ta defines the simulation time the system
        remains in the current state before triggering the internal transition
        function.
        Note that the output may include +∞, since it is possible for a model
        to passivate in a certain state, meaning that it will never have an
        internal transition in this state.
        """
        return math.inf

    @classmethod
    def external_transition(cls, state: S, inputs: Input[I]) -> S:
        """
        The external transition function δext gets called as soon as an external
        input (∈ X) is received in the model. When the external transition function
        is called, the time advance function is called again and the previously
        scheduled internal event is rescheduled with the new value.



        δext is the external transition function, but works on a bag Xb instead
        of a single input. This means that there might be multiple messages on a
        single port and since a bag is used, the order of the messages in the bag
        should not have an influence on the resulting state.
        """
        return state

    @classmethod
    def confluent_transition(cls, state: S, inputs: Input[I]):
        """
        The confluent transition function δcon gets triggered when there is a
        collision between δint and δext (so when a model receives an external
        input at the same time as it would do its own internal transition).
        Most of the time, the user will just want to call δint or δext in some
        order, though it is possible to define it in any way imaginable, maybe
        completely deviating from the other transition functions.
        """
        state = cls.internal_transition(state)
        state = cls.external_transition(state, inputs)
        return state

    @classmethod
    def internal_transition(cls, state: S) -> S:
        """
        The internal transition function δint defines the next sequential state,
        depending on the current state. It is triggered after the time returned
        by the time advance function has passed (in the simulation, not in real time).
        Note that this function does not require the elapsed simulation time
        as an argument, since it will always be equal to the time advance function.
        """
        return state

    @classmethod
    def output(cls, state: S) -> Output[O]:
        """
        The output function λ maps a state onto an output set. Output events are
        only generated by a DEVS model at the time of an internal transition.
        This function is called before the internal transition function is called,
        so the state that is used will be the state before the transition happens.


        λ is the output function, but now it outputs a bag instead of a single output.
        If a single output is desired, a bag with only one element should be sent.

        Remember that in Classic DEVS, only one internal transition will be ran
        at a time, so there will be only one message on the output (possibly on
        multiple output ports) and hence no collisions between messages on a single
        port happen. In Parallel DEVS however, we remove this constraint, making
        multiple messages on a single port possible. To allow this, bags are needed.
        """
        return {}
